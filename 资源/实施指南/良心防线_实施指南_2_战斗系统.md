# 《良心防线》实施指南 - 第二部分：战斗系统

> 接上一部分，本文档教你实现最基础的战斗：员工 vs 敌人，能打能死。

---

## 一、阶段 1 续：让单位能战斗

### 1.6 创建良心防线专用的游戏入口

我们不再用 `SampleGame`，而是写自己的入口脚本。

**创建文件**：`Assets/Scripts/LiangXin/LiangXinGame.cs`

```csharp
using System.Collections.Generic;
using UnityEngine;
using CYFramework.Runtime.Core;
using CYFramework.Runtime.Gameplay.Abstraction;
using CYFramework.Runtime.Gameplay.OOP;
using LiangXin.Data;

namespace LiangXin
{
    /// <summary>
    /// 良心防线 - 游戏主入口
    /// </summary>
    public class LiangXinGame : MonoBehaviour
    {
        [Header("单位管理")]
        public UnitManager unitManager;

        [Header("测试设置")]
        public int testEnemyCount = 5;
        public float spawnRadius = 8f;

        // 玩法世界引用
        private GameplayWorldOOP _world;

        // 实体ID -> 可视化物体
        private Dictionary<int, GameObject> _views = new Dictionary<int, GameObject>();

        // 基地位置
        private Vector3 _basePosition = Vector3.zero;

        private void Start()
        {
            // 等待框架初始化
            if (!CYFW.IsReady)
            {
                Debug.LogError("CYFramework 未初始化！");
                return;
            }

            _world = CYFW.World as GameplayWorldOOP;
            if (_world == null)
            {
                Debug.LogError("玩法世界未创建！");
                return;
            }

            // 订阅事件
            CYFW.Event.Subscribe<DamageEvent>(OnDamage);

            // 开始游戏
            StartGame();
        }

        /// <summary>
        /// 开始游戏：生成初始单位
        /// </summary>
        private void StartGame()
        {
            // 生成一个测试员工（金牌骑手）
            SpawnUnit("F01", new Vector3(-3, 0, 0));

            // 生成一些测试敌人
            for (int i = 0; i < testEnemyCount; i++)
            {
                // 2D: 用 x, y 平面
                Vector2 pos = Random.insideUnitCircle * spawnRadius;
                pos.y = Mathf.Abs(pos.y) + 3f; // 确保在上方生成
                SpawnUnit("E01", new Vector3(pos.x, pos.y, 0));
            }

            Debug.Log($"游戏开始：1名员工 vs {testEnemyCount}名敌人");
        }

        /// <summary>
        /// 生成单位
        /// </summary>
        public int SpawnUnit(string unitId, Vector3 position)
        {
            var config = unitManager.GetConfig(unitId);
            if (config == null)
            {
                Debug.LogError($"找不到单位配置: {unitId}");
                return -1;
            }

            // 在玩法世界中创建实体
            int entityId = _world.SpawnEntity(new EntitySpawnInfo
            {
                Type = config.isEnemy ? EntityType.Enemy : EntityType.Player,
                ConfigId = unitId.GetHashCode(), // 用ID的哈希作为ConfigId
                CampId = config.isEnemy ? 2 : 1, // 1=友军, 2=敌军
                Position = position,
                Rotation = 0f
            });

            // 设置属性（通过扩展数据）
            if (_world.TryGetEntity(entityId, out EntityData data))
            {
                data.MaxHp = config.baseHp;
                data.Hp = config.baseHp;
                data.Attack = config.baseAtk;
                data.MoveSpeed = config.baseMoveSpeed;
                data.AttackRange = config.baseAtkRange;
            }

            // 创建可视化物体
            CreateView(entityId, config);

            return entityId;
        }

        /// <summary>
        /// 创建可视化物体（2D 色块/图片）
        /// </summary>
        private void CreateView(int entityId, UnitConfig config)
        {
            if (!_world.TryGetEntity(entityId, out EntityData data)) return;

            GameObject view;
            if (config.prefab != null)
            {
                // 使用预制体（后期可以是 Spine 动画）
                view = Instantiate(config.prefab);
            }
            else
            {
                // 默认：用 2D 色块
                view = new GameObject(config.unitName);
                var sr = view.AddComponent<SpriteRenderer>();
                
                // 如果有图片就用图片，否则用默认白色方块
                if (config.sprite != null)
                {
                    sr.sprite = config.sprite;
                }
                else
                {
                    // 用 Unity 内置的白色方块
                    sr.sprite = CreateDefaultSquareSprite();
                }
                
                sr.color = config.unitColor;
                view.transform.localScale = Vector3.one * config.spriteScale;
                
                // 友军在上层，敌人在下层
                sr.sortingOrder = config.isEnemy ? 10 : 20;
            }

            view.name = $"{config.unitName}_{entityId}";
            
            // 2D 位置：只用 x 和 y
            view.transform.position = new Vector3(data.Position.x, data.Position.y, 0);

            _views[entityId] = view;
        }
        
        /// <summary>
        /// 创建默认的白色方块 Sprite
        /// </summary>
        private Sprite _defaultSprite;
        private Sprite CreateDefaultSquareSprite()
        {
            if (_defaultSprite != null) return _defaultSprite;
            
            // 创建一个 32x32 的白色纹理
            Texture2D tex = new Texture2D(32, 32);
            Color[] colors = new Color[32 * 32];
            for (int i = 0; i < colors.Length; i++)
                colors[i] = Color.white;
            tex.SetPixels(colors);
            tex.Apply();
            
            _defaultSprite = Sprite.Create(tex, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f), 32);
            return _defaultSprite;
        }

        private void Update()
        {
            if (_world == null || !_world.IsRunning) return;

            // 同步可视化
            SyncViews();

            // 检查战斗结束
            CheckBattleEnd();
        }

        /// <summary>
        /// 同步可视化物体位置
        /// </summary>
        private void SyncViews()
        {
            var entities = _world.GetAllEntities();
            var toRemove = new List<int>();

            foreach (var kvp in _views)
            {
                int entityId = kvp.Key;
                GameObject view = kvp.Value;

                if (_world.TryGetEntity(entityId, out EntityData data))
                {
                    if (data.State == EntityState.Dead)
                    {
                        // 标记移除
                        toRemove.Add(entityId);
                        if (view != null) Destroy(view);
                    }
                    else if (view != null)
                    {
                        // 更新位置（2D：只用 x, y）
                        view.transform.position = new Vector3(data.Position.x, data.Position.y, 0);
                    }
                }
                else
                {
                    // 实体已不存在
                    toRemove.Add(entityId);
                    if (view != null) Destroy(view);
                }
            }

            // 移除已销毁的
            foreach (int id in toRemove)
            {
                _views.Remove(id);
            }
        }

        /// <summary>
        /// 检查战斗结束
        /// </summary>
        private void CheckBattleEnd()
        {
            // 统计存活单位
            int allyCount = 0;
            int enemyCount = 0;

            var entities = _world.GetAllEntities();
            for (int i = 0; i < entities.Count; i++)
            {
                var e = entities[i];
                if (e.State != EntityState.Active) continue;

                if (e.Type == EntityType.Enemy)
                    enemyCount++;
                else
                    allyCount++;
            }

            // 敌人全灭 = 胜利
            if (enemyCount == 0)
            {
                Debug.Log("=== 胜利！所有敌人已消灭 ===");
                _world.Pause();
            }
            // 友军全灭 = 失败
            else if (allyCount == 0)
            {
                Debug.Log("=== 失败！所有员工已阵亡 ===");
                _world.Pause();
            }
        }

        /// <summary>
        /// 伤害事件回调
        /// </summary>
        private void OnDamage(DamageEvent evt)
        {
            Debug.Log($"[伤害] {evt.AttackerId} → {evt.TargetId}: {evt.Damage}点" +
                      (evt.IsCritical ? " (暴击)" : ""));
        }

        private void OnDestroy()
        {
            CYFW.Event?.Unsubscribe<DamageEvent>(OnDamage);

            // 清理视图
            foreach (var view in _views.Values)
            {
                if (view != null) Destroy(view);
            }
            _views.Clear();
        }
    }
}
```

### 1.7 配置场景

1. 在 `CYFramework` 物体上：
   - 移除 `SampleGame` 组件（如果有的话）
   - 添加 `LiangXinGame` 组件
2. 把场景里的 `UnitManager` 拖到 `LiangXinGame` 的 `Unit Manager` 字段
3. 设置测试参数：
   - Test Enemy Count: 5
   - Spawn Radius: 8

### 1.8 运行测试

1. 按 Play
2. 你应该看到：
   - 1 个友军（绿色胶囊）在左边
   - 5 个敌人（红色球）在前方
   - 敌人会自动冲向友军
   - 友军会自动攻击最近的敌人
   - 控制台输出伤害日志

---

## 二、理解战斗是怎么发生的

你可能会问："我没写攻击代码，它们怎么就能打起来了？"

答案：**CYFramework 已经内置了基础的战斗逻辑**。

### 战斗流程

```
每帧 GameplayWorld.Tick()
  → AISystem.Update()      // AI决定：要攻击谁、要移动到哪
  → MovementSystem.Update() // 移动到目标位置
  → CombatSystem.Update()   // 检测攻击距离，造成伤害
  → CleanupSystem.Update()  // 清理死亡的实体
```

### 默认 AI 行为

框架内置的 `AISystem` 做了这些事：
- 敌人：自动寻找最近的友军，冲过去打
- 友军：自动寻找最近的敌人，冲过去打

这正好符合《良心防线》Lv1 员工的行为：**"自主攻击最近敌人，能力有限"**。

---

## 三、自定义战斗行为（进阶）

如果你想让 AI 更智能，或者实现特殊攻击，你可以：

### 方式 1：修改现有系统

获取系统引用，调用它的方法：

```csharp
var aiSystem = _world.GetSystem<AISystem>();
aiSystem.SetAIEnabled(entityId, false); // 关闭某个单位的 AI
```

### 方式 2：创建自己的系统

**创建文件**：`Assets/Scripts/LiangXin/Systems/LiangXinAISystem.cs`

```csharp
using CYFramework.Runtime.Gameplay.Abstraction;
using CYFramework.Runtime.Gameplay.OOP;

namespace LiangXin.Systems
{
    /// <summary>
    /// 良心防线专用 AI 系统
    /// 可以在这里实现：指挥范围、副官、特殊行为等
    /// </summary>
    public class LiangXinAISystem : IGameSystem
    {
        // 优先级：在默认 AI 之前执行
        public int Priority => 70;

        private IGameplayWorld _world;

        public void Initialize(IGameplayWorld world)
        {
            _world = world;
        }

        public void Update(float deltaTime)
        {
            // TODO: 在这里写你的 AI 逻辑
            // 例如：检查员工是否在老板指挥范围内
        }

        public void Shutdown() { }
        public void Reset() { }
    }
}
```

然后在 `LiangXinGame.Start()` 里注册：

```csharp
_world.RegisterSystem(new LiangXinAISystem());
```

---

## 四、下一步

阶段 1 到这里就完成了。你现在有：
- ✅ 框架跑起来了
- ✅ 自己的数据结构（UnitConfig）
- ✅ 自己的游戏入口（LiangXinGame）
- ✅ 员工和敌人能自动战斗

**下一阶段（阶段 2）**：加入"老板"角色
- 老板可以用 WASD 移动
- 老板有指挥范围
- 老板可以给员工下指令

请查看 **良心防线_实施指南_3_老板角色.md**。
