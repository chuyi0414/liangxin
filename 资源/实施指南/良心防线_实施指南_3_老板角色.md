# 《良心防线》实施指南 - 第三部分：老板角色

> 本文档教你实现玩家控制的"良心老板"：能移动、有指挥范围、能下指令。

---

## 一、阶段 2：老板角色

### 目标
- 场景中有一个玩家控制的"老板"
- 老板可以用 WASD/鼠标移动
- 老板有"指挥范围"（靠近员工才能下令）
- 按键可以给范围内员工下指令

---

## 二、创建老板控制器

### 2.1 老板数据

**创建文件**：`Assets/Scripts/LiangXin/Data/BossData.cs`

```csharp
using UnityEngine;

namespace LiangXin.Data
{
    /// <summary>
    /// 老板的运行时数据
    /// </summary>
    public class BossData
    {
        // 基础属性
        public int MaxHp = 100;
        public int Hp = 100;
        public float MoveSpeed = 5f;

        // 指挥系统
        public float CommandRadius = 3f;  // 初始指挥范围（贴脸喊话）

        // 资源
        public int Gold = 0;              // 资金
        public int BlackHeart = 0;        // 黑心（上限100）
        public int Conscience = 100;      // 良心值

        // 状态
        public bool IsDead = false;
        public float RespawnTimer = 0f;   // 复活倒计时

        // 位置
        public Vector3 Position;
    }
}
```

### 2.2 老板控制器

**创建文件**：`Assets/Scripts/LiangXin/BossController.cs`

```csharp
using System.Collections.Generic;
using UnityEngine;
using CYFramework.Runtime.Core;
using CYFramework.Runtime.Gameplay.Abstraction;
using CYFramework.Runtime.Gameplay.OOP;
using LiangXin.Data;

namespace LiangXin
{
    /// <summary>
    /// 老板控制器
    /// 处理移动、指挥、拾取等
    /// </summary>
    public class BossController : MonoBehaviour
    {
        [Header("老板设置")]
        public float moveSpeed = 5f;
        public float commandRadius = 3f;

        [Header("可视化")]
        public GameObject bossModel;          // 老板的模型/形状
        public GameObject commandRangeVisual; // 指挥范围可视化（圆圈）

        // 运行时数据
        public BossData Data { get; private set; }

        // 当前选中的员工
        private List<int> _selectedEmployees = new List<int>();

        // 引用
        private GameplayWorldOOP _world;
        private Camera _mainCamera;

        private void Start()
        {
            _world = CYFW.World as GameplayWorldOOP;
            _mainCamera = Camera.main;

            // 初始化数据
            Data = new BossData
            {
                MoveSpeed = moveSpeed,
                CommandRadius = commandRadius,
                Position = transform.position
            };

            // 创建可视化（2D 色块）
            if (bossModel == null)
            {
                bossModel = new GameObject("BossSprite");
                bossModel.transform.SetParent(transform);
                bossModel.transform.localPosition = Vector3.zero;
                
                var sr = bossModel.AddComponent<SpriteRenderer>();
                // 用默认白色方块，染成金色
                sr.sprite = CreateDefaultSquareSprite();
                sr.color = Color.yellow; // 老板是金色的
                sr.sortingOrder = 50;    // 老板在最上层
                
                bossModel.transform.localScale = Vector3.one * 1.2f; // 比员工大一点
            }

            // 创建指挥范围可视化
            CreateCommandRangeVisual();
        }

        /// <summary>
        /// 创建指挥范围的可视化圆圈（2D）
        /// </summary>
        private void CreateCommandRangeVisual()
        {
            if (commandRangeVisual == null)
            {
                commandRangeVisual = new GameObject("CommandRange");
                commandRangeVisual.transform.SetParent(transform);
                commandRangeVisual.transform.localPosition = Vector3.zero;
                
                var sr = commandRangeVisual.AddComponent<SpriteRenderer>();
                // 创建一个圆形 Sprite
                sr.sprite = CreateCircleSprite();
                sr.color = new Color(0, 1, 0, 0.2f); // 半透明绿色
                sr.sortingOrder = 0; // 在最底层
            }

            UpdateCommandRangeVisual();
        }
        
        /// <summary>
        /// 创建默认方块 Sprite
        /// </summary>
        private Sprite CreateDefaultSquareSprite()
        {
            Texture2D tex = new Texture2D(32, 32);
            Color[] colors = new Color[32 * 32];
            for (int i = 0; i < colors.Length; i++)
                colors[i] = Color.white;
            tex.SetPixels(colors);
            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f), 32);
        }
        
        /// <summary>
        /// 创建圆形 Sprite（用于指挥范围）
        /// </summary>
        private Sprite CreateCircleSprite()
        {
            int size = 64;
            Texture2D tex = new Texture2D(size, size);
            Color[] colors = new Color[size * size];
            float center = size / 2f;
            float radius = size / 2f;
            
            for (int y = 0; y < size; y++)
            {
                for (int x = 0; x < size; x++)
                {
                    float dist = Vector2.Distance(new Vector2(x, y), new Vector2(center, center));
                    colors[y * size + x] = dist < radius ? Color.white : Color.clear;
                }
            }
            tex.SetPixels(colors);
            tex.Apply();
            return Sprite.Create(tex, new Rect(0, 0, size, size), new Vector2(0.5f, 0.5f), size);
        }

        /// <summary>
        /// 更新指挥范围可视化大小（2D）
        /// </summary>
        private void UpdateCommandRangeVisual()
        {
            if (commandRangeVisual == null) return;

            float diameter = Data.CommandRadius * 2f;
            commandRangeVisual.transform.localScale = new Vector3(diameter, diameter, 1);
        }

        private void Update()
        {
            if (Data.IsDead)
            {
                HandleRespawn();
                return;
            }

            // 处理移动
            HandleMovement();

            // 处理指令
            HandleCommands();

            // 更新数据
            Data.Position = transform.position;
        }

        /// <summary>
        /// 处理移动（WASD + 鼠标右键）- 2D版
        /// </summary>
        private void HandleMovement()
        {
            // WASD 移动（2D: x 和 y）
            float h = Input.GetAxis("Horizontal");
            float v = Input.GetAxis("Vertical");

            if (h != 0 || v != 0)
            {
                Vector3 move = new Vector3(h, v, 0).normalized;
                transform.position += move * Data.MoveSpeed * Time.deltaTime;
            }

            // 鼠标右键点击移动（2D）
            if (Input.GetMouseButton(1) && _mainCamera != null)
            {
                Vector3 mouseWorld = _mainCamera.ScreenToWorldPoint(Input.mousePosition);
                mouseWorld.z = 0;

                Vector3 dir = (mouseWorld - transform.position).normalized;
                transform.position += dir * Data.MoveSpeed * Time.deltaTime;
            }
        }

        /// <summary>
        /// 处理指令输入
        /// </summary>
        private void HandleCommands()
        {
            // 获取指挥范围内的员工
            var employeesInRange = GetEmployeesInRange();

            // F - 跟随
            if (Input.GetKeyDown(KeyCode.F))
            {
                IssueCommand(employeesInRange, CommandType.Follow);
            }
            // S - 驻守
            if (Input.GetKeyDown(KeyCode.S))
            {
                IssueCommand(employeesInRange, CommandType.Hold);
            }
            // D - 防御
            if (Input.GetKeyDown(KeyCode.D))
            {
                IssueCommand(employeesInRange, CommandType.Defend);
            }
            // R - 撤退
            if (Input.GetKeyDown(KeyCode.R))
            {
                IssueCommand(employeesInRange, CommandType.Retreat);
            }
        }

        /// <summary>
        /// 获取指挥范围内的员工ID列表
        /// </summary>
        private List<int> GetEmployeesInRange()
        {
            var result = new List<int>();
            if (_world == null) return result;

            var entities = _world.GetAllEntities();
            for (int i = 0; i < entities.Count; i++)
            {
                var e = entities[i];
                // 只选友军、活着的
                if (e.Type == EntityType.Enemy) continue;
                if (e.State != EntityState.Active) continue;

                float dist = Vector3.Distance(Data.Position, e.Position);
                if (dist <= Data.CommandRadius)
                {
                    result.Add(e.Id);
                }
            }

            return result;
        }

        /// <summary>
        /// 下达指令
        /// </summary>
        private void IssueCommand(List<int> targetIds, CommandType type)
        {
            if (targetIds.Count == 0)
            {
                Debug.Log($"[指令] 范围内没有员工");
                return;
            }

            Debug.Log($"[指令] 对 {targetIds.Count} 名员工下达 {type} 指令");

            foreach (int id in targetIds)
            {
                // 发送指令到玩法世界
                _world.ExecuteCommand(new GameplayCommand
                {
                    Type = type,
                    EntityId = id,
                    TargetPosition = transform.position // 用于"跟随"指令
                });
            }
        }

        /// <summary>
        /// 处理复活
        /// </summary>
        private void HandleRespawn()
        {
            Data.RespawnTimer -= Time.deltaTime;

            if (Data.RespawnTimer <= 0)
            {
                // 复活
                Data.IsDead = false;
                Data.Hp = Data.MaxHp / 2; // 复活时只有一半血

                // 惩罚：扣钱或扣良心
                if (Data.Gold >= 100)
                {
                    int penalty = Mathf.RoundToInt(Data.Gold * 0.2f);
                    Data.Gold -= penalty;
                    Debug.Log($"[老板复活] 损失 {penalty} 资金");
                }
                else
                {
                    Data.Conscience -= 30;
                    Debug.Log($"[老板复活] 良心值 -30");
                }

                bossModel?.SetActive(true);
            }
        }

        /// <summary>
        /// 老板受到伤害
        /// </summary>
        public void TakeDamage(int damage)
        {
            Data.Hp -= damage;
            Debug.Log($"[老板] 受到 {damage} 点伤害，剩余 {Data.Hp}/{Data.MaxHp}");

            if (Data.Hp <= 0)
            {
                Die();
            }
        }

        /// <summary>
        /// 老板死亡
        /// </summary>
        private void Die()
        {
            Data.IsDead = true;
            Data.RespawnTimer = 3f; // 3秒后复活
            bossModel?.SetActive(false);
            Debug.Log("[老板] 死亡！3秒后复活...");
        }

        /// <summary>
        /// 拾取资金
        /// </summary>
        public void PickupGold(int amount)
        {
            Data.Gold += amount;
            Debug.Log($"[老板] 拾取 {amount} 资金，当前 {Data.Gold}");
        }

        /// <summary>
        /// 拾取黑心
        /// </summary>
        public void PickupBlackHeart(int amount)
        {
            Data.BlackHeart = Mathf.Min(100, Data.BlackHeart + amount);
            Debug.Log($"[老板] 拾取黑心，当前 {Data.BlackHeart}/100");
        }

        /// <summary>
        /// 升级指挥范围
        /// </summary>
        public void UpgradeCommandRadius(float newRadius)
        {
            Data.CommandRadius = newRadius;
            UpdateCommandRangeVisual();
            Debug.Log($"[老板] 指挥范围升级到 {newRadius} 米");
        }
    }

    /// <summary>
    /// 指令类型
    /// </summary>
    public enum CommandType
    {
        Follow,   // 跟随老板
        Hold,     // 驻守当前位置
        Defend,   // 防御（减伤）
        Retreat,  // 撤退
        Attack    // 攻击指定目标
    }
}
```

### 2.3 把老板加到场景

1. 创建空物体，命名 `Boss`
2. 添加 `BossController` 组件
3. 位置设为 (0, -3, 0)（在2D画面下方，基地附近）

### 2.4 更新 LiangXinGame

在 `LiangXinGame.cs` 中添加对老板的引用：

```csharp
[Header("老板")]
public BossController bossController;
```

然后在 Inspector 里把 `Boss` 物体拖进去。

---

## 三、运行测试

1. 按 Play
2. 你应该看到：
   - 一个金色方块（老板）在场景中
   - 老板身上有一个半透明绿色圆圈（指挥范围）
   - 用 WASD 可以移动老板（上下左右）
   - 走到员工附近，按 F 可以让员工跟随
3. 控制台会输出指令日志

---

## 四、下一步

阶段 2 完成了。你现在有：
- ✅ 可控制的老板角色
- ✅ 指挥范围可视化
- ✅ 基础指令系统（跟随/驻守/防御/撤退）

**下一阶段（阶段 3）**：波次系统
- 敌人分波刷新
- 波次预警（显示进攻方向）
- 布阵期

请查看 **良心防线_实施指南_4_波次系统.md**。
